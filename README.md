# 라멘땅 (Ramenddang) - Personal Project
>  라멘 맛집 조회 및 추천 커뮤니티 플랫폼
<br/>

## 1. 제작기간
개발기간 
- 24.09.21 ~ 24.10.05 (BE완료)
<br/>

## 2. 사용기술
### **Back-end**
- Java 17
- Spring Boot 3.3.2
- Spring Security 6.2.1
- JPA
- Redis 3.0.504
- JWT 0.12.3 

### **Database**
- MySQL 8.0.36

### **Infra**
- AWS EC2
<br/>

## 3. ERD 설계
![erdfile](https://github.com/billihazero/portfolio/blob/main/images/image.png)
<br/>

## 4. 핵심 기능

### 4-1. Spring Security + JWT 활용 인증기반 로그인 / 로그아웃 
- 로그인 시 Access Token과 Refresh Token 동시 발급
- SecurityContextHolder를 통해 인증된 사용자 정보 저장 및 API 호출 시 사용
- Access Token 만료 시 Refresh Token을 통해 Access Token을 재발급

<br/>

### 4-2. Redis 기반 토큰 캐싱 및 만료 관리
- Refresh Token을 Redis와 DB에 저장
- Refresh Token의 만료 시간 설정 및 만료 시 자동 삭제
- Redis에서 Token 조회 및 검증을 통해 인증 처리
- 로그아웃 시 Redis에서 해당 Token 삭제

<br/>

### 4-3. 관리자 / 일반 회원 권한 분리
- 관리자와 일반 회원의 권한을 분리하여 접근 제어
    - 관리자 : 가게 글 작성, 수정, 삭제
    - 일반 회원 : Only 조회
- Spring Security를 통한 권한 기반 접근 제어 구현

<br/>

### 4-4. 다중 이미지 업로드 및 수정 기능
- 다중 이미지 업로드 및 관리 기능 제공
- 이름 중복 방지를 위해 UUID를 사용하여 이미지 이름 저장
- 수정 시, 기존 이미지와 비교하여 변경된 이미지만 업데이트

<br/>

## 5. 트러블 슈팅

### 5-1. JWT 인증과 Token 처리
#### 배경
- API 요청 때 마다 Token을 parsing 하여 Token의 정보를 활용, Refresh Token 만료 시 새로운 Token을 재발급 해주는 것을 계획했다.

#### 문제
-  API 요청 때 마다 token을 매번 parsing하여 정보를 가져오는게 맞는지 ?
-  Refresh Token이 만료 되었을 경우 refresh Token을 재발급 해주는 기능을 만드는 것이 맞는지?
-  Refresh Token의 만료시간을 어떻게 관리할 것인지?

#### 해결방안
- 토큰을 매번 parsing하여 정보를 가져오는게 맞는지 : 토큰에서 주로 필요했던 정보는 사용자의 id였다. 그렇다면 토큰에서 가져오는 것 보다는 spring security가 관리하는 인증 컨텍스트에서 정보를 가져오는 것이 더 좋은 선택이라고 생각했다. 
    - 보안성 : 이미 spring security를 통해 인증과 권한 부여를 관리하고 있기 때문에 직접 토큰을 처리하는 것보다 안전하고 일관된 방식으로 진행할 수 있다.
    - 재사용성과 유지보수 : 인증된 사용자의 정보는 여러 클래스에서 필요할 수 있는데, SecurityContextHolder에서 가져오는 방식은 어디서든 쉽게 사용할 수 있다.

- Refresh 토큰이 만료되었을 때 : 보안 강화 vs Ux 문제를 고민했다. 재발행 기능을 추가한다면 사용자가 재로그인 해야하는 귀찮음이 발생하기 때문에 사용자의 만족도를 떨어뜨릴 수 있다고 생각했다. 하지만, 재발행 기능을 만든다면, 편리성은 증가하지만 세션 탈취의 위험과 같은 보안 리스크가 발생하기 때문에 리스크를 방지하기 위하여 refresh 토큰이 만료된다면 재로그인을 요구하는 방향으로 잡았다.

- refresh 토큰의 만료시간 관리 :  만료시간 관리와 속도를 위해 redis를 활용했다. refresh 토큰이 발행될 때 redis에 만료시간을 설정하여 저장하였다.

### 5-2. 다중 이미지 수정 로직 처리
#### 배경
- 다중 이미지를 업로드 한 후, 기존 이미지 중 일부를 삭제하고 새로운 이미지를 추가해야 하는 상황을 처리하는 로직에 대해 고민하였다. 예를 들어, 3장의 이미지를 업로드 한 후, 1장을 삭제하고 새로운 이미지 1장을 추가하는 경우, 이를 정확히 반영하는 로직을 구현하는 것이 어려웠다.

#### 문제
- 기존 이미지와 새로운 이미지의 차이를 구분해야하며, 중복되는 이미지를 제외하고 새로운 이미지만 추가하는 로직이 필요했다.

- 기존 이미지 목록과 새로 업로드 된 이미지 목록을 비교하여, 삭제할 이미지와 추가할 이미지를 처리하는 로직을 생각하는 것이 어려웠다.

#### 해결방안
- DB에 저장된 기존 이미지를 불러오고, 새로 업로드 된 이미지와 비교하여 겹치지 않는 이미지를 삭제할 이미지 목록에 추가하여 삭제 로직을 구현했다.
- 기존 이미지와 중복되지 않은 새로운 이미지 파일만 저장하여 중복 저장을 방지했다.

## 6. 그 외 트러블 슈팅

#### 6-1. 순환참조 문제
- 연관관계 매핑을 통해 관계 설정이 된 객체를 출력했을 때 순환참조가 발생해서 데이터가 계속해서 출력되는 문제가 있었다.

- @JsonManagedReference, @JsonBackReference 어노테이션을 통해 문제를 해결했다.
JsonManagedReference는 부모 객체에, JsonBackReference는 자식 객체에 작성한다.
두 어노테이션은 양방향 관계를 처리할 때 무한 순환 참조 문제를 방지하기 위해 사용된다.

#### 6-2. Postman multifile Post 415 에러
- Postman에서 데이터 전송하는것이 문제였다. Content-type을 선택한 후에 part별 type을 자세하게 선택했어야 했다.

<details>
<summary>진행상황 </summary>
- 회원
  - 회원가입
    - 패스워드 암호화 (완료)
    - 프로필 이미지 (완료) 
    
    
  - 로그인 / 로그아웃
    - jwt 로그인 (완료)
    - redis 캐시 (완료 - 응답 속도 확인하기)
    
  
  - 회원 정보
    - 정보 수정 (완료)
    - 회원 탈퇴 (완료)
    
  
- 관리자
  - 로그인(완료)
  

- 가게
  - 가게 조회
    - 전체 조회 (완료)
    - 상세 조회 (완료)

  - 가게 작성 (완료)
  - 가게 다중이미지 (완료)
  - 가게 수정 (완료)
  - 가게 삭제 (완료)


- 북마크
  - 북마크 추가 (완료)
  - 북마크 삭제 (완료)
  - 가게 조회 시 북마크 표시
  - 북마크 리스트 (완료)



- 가게 리뷰(다중이미지)
  - 포토리뷰 작성 (완료)
  - 포토리뷰 조회 (완료)
  - 포토리뷰 삭제 (완료)


- 가게 요청
    - 작성
    - 삭제
    - 조회수

</details>